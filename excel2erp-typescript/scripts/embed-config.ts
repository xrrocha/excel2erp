#!/usr/bin/env bun
/**
 * Embedded Build Script
 *
 * Generates an embedded build with YAML config and logo images bundled
 * directly into the HTML file.
 *
 * Usage:
 *   bun scripts/embed-config.ts <config.yaml> <output.html>
 *
 * Example:
 *   bun scripts/embed-config.ts shared/excel2erp.yaml dist/lho/excel2erp.html
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { dirname, join, resolve, extname } from 'path';
import { execSync } from 'child_process';
import YAML from 'yaml';

// MIME types by extension
const MIME_TYPES: Record<string, string> = {
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.webp': 'image/webp',
  '.svg': 'image/svg+xml',
};

interface RawConfig {
  port?: number;
  assetsDir?: string;
  config?: RawConfigInner;
  name?: string;
  description?: string;
  logo?: string;
  parameters?: Record<string, unknown>;
  sources?: RawSource[];
  result?: Record<string, unknown>;
}

interface RawConfigInner {
  name: string;
  description: string;
  logo?: string;
  parameters: Record<string, unknown>;
  sources: RawSource[];
  result: Record<string, unknown>;
}

interface RawSource {
  name: string;
  description: string;
  logo?: string;
  [key: string]: unknown;
}

function printUsage(): void {
  console.log(`
Usage: bun scripts/embed-config.ts <config.yaml> <output.html>

Arguments:
  config.yaml   Path to YAML configuration file
  output.html   Output path for embedded HTML file

Example:
  bun scripts/embed-config.ts shared/excel2erp.yaml dist/lho/excel2erp.html
`);
}

function getMimeType(filename: string): string {
  const ext = extname(filename).toLowerCase();
  return MIME_TYPES[ext] || 'application/octet-stream';
}

function encodeLogoToDataUrl(logoPath: string): string {
  const buffer = readFileSync(logoPath);
  const base64 = buffer.toString('base64');
  const mimeType = getMimeType(logoPath);
  return `data:${mimeType};base64,${base64}`;
}

function main(): void {
  const args = process.argv.slice(2);

  if (args.length !== 2) {
    printUsage();
    process.exit(1);
  }

  const [configPath, outputPath] = args;

  // Resolve paths
  const absoluteConfigPath = resolve(configPath);
  const absoluteOutputPath = resolve(outputPath);
  const configDir = dirname(absoluteConfigPath);

  // Check config file exists
  if (!existsSync(absoluteConfigPath)) {
    console.error(`Error: Configuration file not found: ${absoluteConfigPath}`);
    process.exit(1);
  }

  console.log(`Reading config: ${absoluteConfigPath}`);

  // Read and parse YAML
  const yamlContent = readFileSync(absoluteConfigPath, 'utf-8');
  const rawConfig = YAML.parse(yamlContent) as RawConfig;

  // Detect nested vs flat structure
  const isNested = rawConfig.config !== undefined;
  const configData = isNested ? rawConfig.config! : rawConfig as RawConfigInner;

  console.log(`Config format: ${isNested ? 'nested' : 'flat'}`);
  console.log(`Config name: ${configData.name}`);
  console.log(`Sources: ${configData.sources.length}`);

  // Collect logo filenames
  const logoFiles = new Set<string>();
  if (configData.logo) {
    logoFiles.add(configData.logo);
  }
  for (const source of configData.sources) {
    if (source.logo) {
      logoFiles.add(source.logo);
    }
  }

  console.log(`Logos to embed: ${logoFiles.size}`);

  // Determine assets directories to search (in order of preference)
  // 1. assetsDir if specified (relative to config directory)
  // 2. Same directory as config file (fallback)
  const searchDirs: string[] = [];
  if (isNested && rawConfig.assetsDir) {
    searchDirs.push(resolve(configDir, rawConfig.assetsDir));
  }
  searchDirs.push(configDir);

  // Read and encode logos (search multiple directories)
  const embeddedLogos: Record<string, string> = {};
  for (const logoFile of logoFiles) {
    let found = false;
    for (const dir of searchDirs) {
      const logoPath = join(dir, logoFile);
      if (existsSync(logoPath)) {
        console.log(`  Encoding: ${logoFile}`);
        embeddedLogos[logoFile] = encodeLogoToDataUrl(logoPath);
        found = true;
        break;
      }
    }
    if (!found) {
      console.warn(`  Warning: Logo not found: ${logoFile}`);
      console.warn(`    Searched in: ${searchDirs.join(', ')}`);
    }
  }

  // Normalize config to flat structure for embedding
  const flatYaml = isNested
    ? YAML.stringify(configData)
    : yamlContent;

  // Generate embedded.generated.ts
  const generatedContent = `/**
 * Embedded Config (Generated)
 *
 * This file was generated by scripts/embed-config.ts
 * from: ${absoluteConfigPath}
 *
 * DO NOT EDIT - regenerate using:
 *   bun scripts/embed-config.ts ${configPath} ${outputPath}
 */

/** Embedded YAML configuration */
export const embeddedYaml: string | null = ${JSON.stringify(flatYaml)};

/** Embedded logos as data URLs */
export const embeddedLogos: Record<string, string> = ${JSON.stringify(embeddedLogos, null, 2)};
`;

  const generatedPath = join(dirname(import.meta.dir), 'src/config/embedded.generated.ts');
  console.log(`Writing: ${generatedPath}`);
  writeFileSync(generatedPath, generatedContent);

  // Run vite build
  console.log('Running vite build...');
  try {
    execSync('bunx vite build', {
      cwd: dirname(import.meta.dir),
      stdio: 'inherit',
    });
  } catch (error) {
    console.error('Build failed');
    process.exit(1);
  }

  // Ensure output directory exists
  const outputDir = dirname(absoluteOutputPath);
  if (!existsSync(outputDir)) {
    console.log(`Creating directory: ${outputDir}`);
    mkdirSync(outputDir, { recursive: true });
  }

  // Move built file to output location
  const builtPath = join(dirname(import.meta.dir), 'dist/index.html');
  if (!existsSync(builtPath)) {
    console.error(`Error: Built file not found: ${builtPath}`);
    process.exit(1);
  }

  console.log(`Moving: ${builtPath} -> ${absoluteOutputPath}`);
  const builtContent = readFileSync(builtPath);
  writeFileSync(absoluteOutputPath, builtContent);

  // Restore stub for generic builds
  console.log('Restoring generic build stub...');
  const stubContent = `/**
 * Embedded Config (Generated)
 *
 * This file is a stub for generic builds.
 * For embedded builds, this file is replaced by scripts/embed-config.ts
 * with actual YAML config and base64-encoded logos.
 *
 * DO NOT EDIT - this file is overwritten by the embed build script.
 */

/** Embedded YAML configuration (null for generic builds) */
export const embeddedYaml: string | null = null;

/** Embedded logos as data URLs (empty for generic builds) */
export const embeddedLogos: Record<string, string> = {};
`;
  writeFileSync(generatedPath, stubContent);

  console.log(`\nEmbedded build complete: ${absoluteOutputPath}`);
}

main();
